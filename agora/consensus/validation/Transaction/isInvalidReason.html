<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8"/>
		<title>Function isInvalidReason</title>
		<link rel="stylesheet" type="text/css" href="../../../../styles/ddox.css"/>
		<link rel="stylesheet" href="../../../../prettify/prettify.css" type="text/css"/>
		<script type="text/javascript" src="../../../../scripts/jquery.js">/**/</script><script type="text/javascript" src="../../../../scripts/ddox.js">/**/</script>
	</head>
	<body onload="setupDdox();">
		<nav id="main-nav">
			<noscript>
				<p style="color: red">The search functionality needs JavaScript enabled</p>
			</noscript>
			<div id="symbolSearchPane" style="display: none">
				<form action="#" method="GET">
					<input id="symbolSearch" type="text" name="q" placeholder="Search for symbols" autocomplete="off" onchange="performSymbolSearch(40);" onkeypress="this.onchange();" onpaste="this.onchange();" oninput="this.onchange();"/>
				</form>
				<ul id="symbolSearchResults" class="symbolList" style="display: none"></ul><script type="application/javascript" src="../../../../symbols.js"></script><script type="application/javascript">var symbolSearchRootDir = "../../../../";
$('#symbolSearchPane').show();</script>
			</div>
			<ul class="tree-view">
				<li class="tree-view ">
					<div class="package ">agora
					</div>
			<ul class="tree-view">
				<li class="tree-view collapsed">
					<div class="package ">api
					</div>
			<ul class="tree-view">
				<li class="tree-view collapsed">
					<div class="package ">handler
					</div>
			<ul class="tree-view">
				<li>
					<div class="module ">
						<a href="../../../../agora/api/handler/BlockExternalizedHandler.html">BlockExternalizedHandler</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/api/handler/PreImageReceivedHandler.html">PreImageReceivedHandler</a>
					</div>
				</li>
			</ul>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/api/FullNode.html">FullNode</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/api/Validator.html">Validator</a>
					</div>
				</li>
			</ul>
				</li>
				<li class="tree-view collapsed">
					<div class="package ">common
					</div>
			<ul class="tree-view">
				<li class="tree-view collapsed">
					<div class="package ">crypto
					</div>
			<ul class="tree-view">
				<li>
					<div class="module ">
						<a href="../../../../agora/common/crypto/Crc16.html">Crc16</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/common/crypto/ECC.html">ECC</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/common/crypto/Key.html">Key</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/common/crypto/Schnorr.html">Schnorr</a>
					</div>
				</li>
			</ul>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/common/Amount.html">Amount</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/common/BanManager.html">BanManager</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/common/BitField.html">BitField</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/common/Config.html">Config</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/common/Hash.html">Hash</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/common/ManagedDatabase.html">ManagedDatabase</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/common/Metadata.html">Metadata</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/common/SCPHash.html">SCPHash</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/common/Serializer.html">Serializer</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/common/Set.html">Set</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/common/Task.html">Task</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/common/TransactionPool.html">TransactionPool</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/common/Types.html">Types</a>
					</div>
				</li>
			</ul>
				</li>
				<li class="tree-view ">
					<div class="package ">consensus
					</div>
			<ul class="tree-view">
				<li class="tree-view collapsed">
					<div class="package ">data
					</div>
			<ul class="tree-view">
				<li class="tree-view collapsed">
					<div class="package ">
						<a href="../../../../agora/consensus/data/genesis.html">genesis</a>
					</div>
			<ul class="tree-view">
				<li>
					<div class="module ">
						<a href="../../../../agora/consensus/data/genesis/Coinnet.html">Coinnet</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/consensus/data/genesis/Test.html">Test</a>
					</div>
				</li>
			</ul>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/consensus/data/Block.html">Block</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/consensus/data/ConsensusData.html">ConsensusData</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/consensus/data/ConsensusParams.html">ConsensusParams</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/consensus/data/Enrollment.html">Enrollment</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/consensus/data/PreImageInfo.html">PreImageInfo</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/consensus/data/Transaction.html">Transaction</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/consensus/data/UTXOSetValue.html">UTXOSetValue</a>
					</div>
				</li>
			</ul>
				</li>
				<li class="tree-view collapsed">
					<div class="package ">protocol
					</div>
			<ul class="tree-view">
				<li>
					<div class="module ">
						<a href="../../../../agora/consensus/protocol/Nominator.html">Nominator</a>
					</div>
				</li>
			</ul>
				</li>
				<li class="tree-view ">
					<div class="package ">
						<a href="../../../../agora/consensus/validation.html">validation</a>
					</div>
			<ul class="tree-view">
				<li>
					<div class="module ">
						<a href="../../../../agora/consensus/validation/Block.html">Block</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/consensus/validation/Enrollment.html">Enrollment</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/consensus/validation/PreImage.html">PreImage</a>
					</div>
				</li>
				<li>
					<div class="module selected">
						<a href="../../../../agora/consensus/validation/Transaction.html">Transaction</a>
					</div>
				</li>
			</ul>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/consensus/EnrollmentManager.html">EnrollmentManager</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/consensus/EnrollmentPool.html">EnrollmentPool</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/consensus/PreImage.html">PreImage</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/consensus/Quorum.html">Quorum</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/consensus/UTXOSet.html">UTXOSet</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/consensus/ValidatorSet.html">ValidatorSet</a>
					</div>
				</li>
			</ul>
				</li>
				<li class="tree-view collapsed">
					<div class="package ">network
					</div>
			<ul class="tree-view">
				<li>
					<div class="module ">
						<a href="../../../../agora/network/NetworkClient.html">NetworkClient</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/network/NetworkManager.html">NetworkManager</a>
					</div>
				</li>
			</ul>
				</li>
				<li class="tree-view collapsed">
					<div class="package ">node
					</div>
			<ul class="tree-view">
				<li>
					<div class="module ">
						<a href="../../../../agora/node/BlockStorage.html">BlockStorage</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/node/FullNode.html">FullNode</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/node/Ledger.html">Ledger</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/node/main.html">main</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/node/Runner.html">Runner</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/node/Validator.html">Validator</a>
					</div>
				</li>
			</ul>
				</li>
				<li class="tree-view collapsed">
					<div class="package ">test
					</div>
			<ul class="tree-view">
				<li>
					<div class="module ">
						<a href="../../../../agora/test/BanManager.html">BanManager</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/test/Base.html">Base</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/test/EnrollmentManager.html">EnrollmentManager</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/test/GenesisBlock.html">GenesisBlock</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/test/GossipProtocol.html">GossipProtocol</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/test/Ledger.html">Ledger</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/test/ManyValidators.html">ManyValidators</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/test/NetworkClient.html">NetworkClient</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/test/NetworkDiscovery.html">NetworkDiscovery</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/test/NetworkManager.html">NetworkManager</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/test/Quorum.html">Quorum</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/test/QuorumPreimage.html">QuorumPreimage</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/test/Restart.html">Restart</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/test/Simple.html">Simple</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/test/ValidatorCount.html">ValidatorCount</a>
					</div>
				</li>
			</ul>
				</li>
				<li class="tree-view collapsed">
					<div class="package ">utils
					</div>
			<ul class="tree-view">
				<li>
					<div class="module ">
						<a href="../../../../agora/utils/Log.html">Log</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/utils/PrettyPrinter.html">PrettyPrinter</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/utils/SCPPrettyPrinter.html">SCPPrettyPrinter</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/utils/Test.html">Test</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../agora/utils/WellKnownKeys.html">WellKnownKeys</a>
					</div>
				</li>
			</ul>
				</li>
			</ul>
				</li>
				<li class="tree-view collapsed">
					<div class="package ">scpd
					</div>
			<ul class="tree-view">
				<li class="tree-view collapsed">
					<div class="package ">quorum
					</div>
			<ul class="tree-view">
				<li>
					<div class="module ">
						<a href="../../../../scpd/quorum/QuorumIntersectionChecker.html">QuorumIntersectionChecker</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../scpd/quorum/QuorumTracker.html">QuorumTracker</a>
					</div>
				</li>
			</ul>
				</li>
				<li class="tree-view collapsed">
					<div class="package ">scp
					</div>
			<ul class="tree-view">
				<li>
					<div class="module ">
						<a href="../../../../scpd/scp/BallotProtocol.html">BallotProtocol</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../scpd/scp/LocalNode.html">LocalNode</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../scpd/scp/NominationProtocol.html">NominationProtocol</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../scpd/scp/QuorumSetUtils.html">QuorumSetUtils</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../scpd/scp/SCP.html">SCP</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../scpd/scp/SCPDriver.html">SCPDriver</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../scpd/scp/Slot.html">Slot</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../scpd/scp/Utils.html">Utils</a>
					</div>
				</li>
			</ul>
				</li>
				<li class="tree-view collapsed">
					<div class="package ">tests
					</div>
			<ul class="tree-view">
				<li>
					<div class="module ">
						<a href="../../../../scpd/tests/GlueTypes.html">GlueTypes</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../scpd/tests/LayoutTest.html">LayoutTest</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../scpd/tests/SizeTest.html">SizeTest</a>
					</div>
				</li>
			</ul>
				</li>
				<li class="tree-view collapsed">
					<div class="package ">types
					</div>
			<ul class="tree-view">
				<li>
					<div class="module ">
						<a href="../../../../scpd/types/Stellar_SCP.html">Stellar_SCP</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../scpd/types/Stellar_types.html">Stellar_types</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../scpd/types/Utils.html">Utils</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../scpd/types/XDRBase.html">XDRBase</a>
					</div>
				</li>
			</ul>
				</li>
				<li>
					<div class="module ">
						<a href="../../../../scpd/Cpp.html">Cpp</a>
					</div>
				</li>
			</ul>
				</li>
			</ul>
		</nav>
		<div id="main-contents">
			<h1>Function isInvalidReason</h1><p>Get result of transaction data and signature verification
</p>
			<div class="prototype">
				<code class="lang-d">
					<div class="single-prototype">
			<span class="typ">string</span> <span class="pln">isInvalidReason</span>
			<span class="pun">(</span>
			<br/>
			&nbsp;&nbsp;<span class="kwd">const</span><span class="pun">(</span><a href="../../../../agora/consensus/data/Transaction/Transaction.html"><span class="typ">Transaction</span></a><span class="pun">)</span> <span class="pln">tx</span><span class="pun">,</span>
			<br/>
			&nbsp;&nbsp;<span class="kwd">nothrow</span> <span class="kwd">@safe</span> <span class="typ">bool</span> <span class="kwd">delegate</span><span class="pun">(</span><span class="pln">geod24<wbr/></span><span class="pun">.</span><span class="pln">bitblob<wbr/></span><span class="pun">.</span><span class="typ">BitBlob</span>!(512L)<span class="pun">, </span><span class="typ">ulong</span><span class="pun">, </span><span class="kwd">out</span> <a href="../../../../agora/consensus/data/UTXOSetValue/UTXOSetValue.html"><span class="typ">UTXOSetValue</span></a><span class="pun">)</span> <span class="pln">findUTXO</span><span class="pun">,</span>
			<br/>
			&nbsp;&nbsp;<a href="../../../../agora/common/Types/Height.html"><span class="typ">Height</span></a> <span class="pln">height</span>
			<br/>
			<span class="pun">)</span><span class="pln"> </span><span class="kwd">nothrow @safe</span><span class="pun">;</span>
					</div>
				</code>
			</div>
			<section></section>

			<section><h2>Parameters</h2>
<table><col class="caption"><tr><th>Name</th><th>Description</th></tr>
<tr><td id="tx">tx</td><td> <code class="lang-d"><span class="typ">Transaction</span></code></td></tr>
<tr><td id="findUTXO">findUTXO</td><td> delegate for finding <code class="lang-d"><span class="typ">Output</span></code></td></tr>
<tr><td id="height">height</td><td> height of block</td></tr>
</table>
</section>
<section><h2>Return</h2>
<p><code class="lang-d"><span class="kwd">null</span></code> if the transaction is valid, a string explaining the reason it
        is invalid otherwise.
</p>
</section>
<section><h2>Example</h2>
<p>verify transaction data
</p>
<pre class="code"><code class="lang-d"><span class="kwd">import </span><span class="pln">std<wbr/></span><span class="pun">.</span><span class="pln">format</span><span class="pun">;

</span><span class="kwd">scope </span><span class="pln">storage </span><span class="pun">= </span><span class="kwd">new </span><span class="typ">TestUTXOSet</span><span class="pun">;
</span><span class="typ">KeyPair</span><span class="pun">[] </span><span class="pln">key_pairs </span><span class="pun">= [</span><span class="typ">KeyPair<wbr/></span><span class="pun">.</span><span class="pln">random</span><span class="pun">, </span><span class="typ">KeyPair<wbr/></span><span class="pun">.</span><span class="pln">random</span><span class="pun">, </span><span class="typ">KeyPair<wbr/></span><span class="pun">.</span><span class="pln">random</span><span class="pun">, </span><span class="typ">KeyPair<wbr/></span><span class="pun">.</span><span class="pln">random</span><span class="pun">];

</span><span class="com">// Creates the first transaction.
</span><span class="typ">Transaction </span><span class="pln">previousTx </span><span class="pun">= </span><span class="pln">newCoinbaseTX</span><span class="pun">(</span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">address</span><span class="pun">, </span><span class="typ">Amount</span><span class="pun">(</span><span class="lit">100</span><span class="pun">));

</span><span class="com">// Save
</span><span class="typ">Hash </span><span class="pln">previousHash </span><span class="pun">= </span><span class="pln">hashFull</span><span class="pun">(</span><span class="pln">previousTx</span><span class="pun">);
</span><span class="pln">storage<wbr/></span><span class="pun">.</span><span class="pln">put</span><span class="pun">(</span><span class="pln">previousTx</span><span class="pun">);

</span><span class="com">// Creates the second transaction.
</span><span class="typ">Transaction </span><span class="pln">secondTx </span><span class="pun">= </span><span class="typ">Transaction</span><span class="pun">(
    </span><span class="typ">TxType<wbr/></span><span class="pun">.</span><span class="typ">Payment</span><span class="pun">,
    [
        </span><span class="typ">Input</span><span class="pun">(</span><span class="pln">previousHash</span><span class="pun">, </span><span class="lit">0</span><span class="pun">)
    ],
    [
        </span><span class="typ">Output</span><span class="pun">(</span><span class="typ">Amount</span><span class="pun">(</span><span class="lit">50</span><span class="pun">), </span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]<wbr/>.</span><span class="pln">address</span><span class="pun">)
    ]
);

</span><span class="pln">secondTx<wbr/></span><span class="pun">.</span><span class="pln">inputs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">signature </span><span class="pun">= </span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">secret<wbr/></span><span class="pun">.</span><span class="pln">sign</span><span class="pun">(</span><span class="pln">hashFull</span><span class="pun">(</span><span class="pln">secondTx</span><span class="pun">)[]);

</span><span class="com">// It is validated. (the sum of `Output` &lt; the sum of `Input`)
</span><span class="kwd">assert</span><span class="pun">(</span><span class="pln">secondTx<wbr/></span><span class="pun">.</span><span class="pln">isValid</span><span class="pun">(&amp;</span><span class="pln">storage<wbr/></span><span class="pun">.</span><span class="pln">findUTXO</span><span class="pun">, </span><span class="typ">Height</span><span class="pun">(</span><span class="lit">0</span><span class="pun">)),
       </span><span class="pln">format</span><span class="pun">(</span><span class="str">"Transaction data is not validated %s"</span><span class="pun">, </span><span class="pln">secondTx</span><span class="pun">));

</span><span class="pln">secondTx<wbr/></span><span class="pun">.</span><span class="pln">outputs </span><span class="pun">~= </span><span class="typ">Output</span><span class="pun">(</span><span class="typ">Amount</span><span class="pun">(</span><span class="lit">50</span><span class="pun">), </span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">2</span><span class="pun">]<wbr/>.</span><span class="pln">address</span><span class="pun">);
</span><span class="pln">secondTx<wbr/></span><span class="pun">.</span><span class="pln">inputs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">signature </span><span class="pun">= </span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">secret<wbr/></span><span class="pun">.</span><span class="pln">sign</span><span class="pun">(</span><span class="pln">hashFull</span><span class="pun">(</span><span class="pln">secondTx</span><span class="pun">)[]);

</span><span class="com">// It is validated. (the sum of `Output` == the sum of `Input`)
</span><span class="kwd">assert</span><span class="pun">(</span><span class="pln">secondTx<wbr/></span><span class="pun">.</span><span class="pln">isValid</span><span class="pun">(&amp;</span><span class="pln">storage<wbr/></span><span class="pun">.</span><span class="pln">findUTXO</span><span class="pun">, </span><span class="typ">Height</span><span class="pun">(</span><span class="lit">0</span><span class="pun">)),
       </span><span class="pln">format</span><span class="pun">(</span><span class="str">"Transaction data is not validated %s"</span><span class="pun">, </span><span class="pln">secondTx</span><span class="pun">));

</span><span class="pln">secondTx<wbr/></span><span class="pun">.</span><span class="pln">outputs </span><span class="pun">~= </span><span class="typ">Output</span><span class="pun">(</span><span class="typ">Amount</span><span class="pun">(</span><span class="lit">50</span><span class="pun">), </span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">3</span><span class="pun">]<wbr/>.</span><span class="pln">address</span><span class="pun">);
</span><span class="pln">secondTx<wbr/></span><span class="pun">.</span><span class="pln">inputs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">signature </span><span class="pun">= </span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">secret<wbr/></span><span class="pun">.</span><span class="pln">sign</span><span class="pun">(</span><span class="pln">hashFull</span><span class="pun">(</span><span class="pln">secondTx</span><span class="pun">)[]);

</span><span class="com">// It isn't validated. (the sum of `Output` &gt; the sum of `Input`)
</span><span class="kwd">assert</span><span class="pun">(!</span><span class="pln">secondTx<wbr/></span><span class="pun">.</span><span class="pln">isValid</span><span class="pun">(&amp;</span><span class="pln">storage<wbr/></span><span class="pun">.</span><span class="pln">findUTXO</span><span class="pun">, </span><span class="typ">Height</span><span class="pun">(</span><span class="lit">0</span><span class="pun">)),
       </span><span class="pln">format</span><span class="pun">(</span><span class="str">"Transaction data is not validated %s"</span><span class="pun">, </span><span class="pln">secondTx</span><span class="pun">));
</span></code></pre>
</section>
<section><h2>Example</h2>
<p>negative output amounts disallowed
</p>
<pre class="code"><code class="lang-d"><span class="typ">KeyPair</span><span class="pun">[] </span><span class="pln">key_pairs </span><span class="pun">= [</span><span class="typ">KeyPair<wbr/></span><span class="pun">.</span><span class="pln">random</span><span class="pun">(), </span><span class="typ">KeyPair<wbr/></span><span class="pun">.</span><span class="pln">random</span><span class="pun">()];
</span><span class="typ">Transaction </span><span class="pln">tx_1 </span><span class="pun">= </span><span class="pln">newCoinbaseTX</span><span class="pun">(</span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">address</span><span class="pun">, </span><span class="typ">Amount</span><span class="pun">(</span><span class="lit">1000</span><span class="pun">));
</span><span class="typ">Hash </span><span class="pln">tx_1_hash </span><span class="pun">= </span><span class="pln">hashFull</span><span class="pun">(</span><span class="pln">tx_1</span><span class="pun">);

</span><span class="kwd">scope </span><span class="pln">storage </span><span class="pun">= </span><span class="kwd">new </span><span class="typ">TestUTXOSet</span><span class="pun">;
</span><span class="pln">storage<wbr/></span><span class="pun">.</span><span class="pln">put</span><span class="pun">(</span><span class="pln">tx_1</span><span class="pun">);

</span><span class="com">// Creates the second transaction.
</span><span class="typ">Transaction </span><span class="pln">tx_2 </span><span class="pun">=
{
    </span><span class="typ">TxType<wbr/></span><span class="pun">.</span><span class="typ">Payment</span><span class="pun">,
    </span><span class="pln">inputs  </span><span class="pun">: [</span><span class="typ">Input</span><span class="pun">(</span><span class="pln">tx_1_hash</span><span class="pun">, </span><span class="lit">0</span><span class="pun">)],
    </span><span class="com">// oops
    </span><span class="pln">outputs </span><span class="pun">: [</span><span class="typ">Output</span><span class="pun">(</span><span class="typ">Amount<wbr/></span><span class="pun">.</span><span class="pln">invalid</span><span class="pun">(-</span><span class="lit">400_000</span><span class="pun">), </span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]<wbr/>.</span><span class="pln">address</span><span class="pun">)]
};

</span><span class="pln">tx_2<wbr/></span><span class="pun">.</span><span class="pln">inputs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">signature </span><span class="pun">= </span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">secret<wbr/></span><span class="pun">.</span><span class="pln">sign</span><span class="pun">(</span><span class="pln">hashFull</span><span class="pun">(</span><span class="pln">tx_2</span><span class="pun">)[]);

</span><span class="kwd">assert</span><span class="pun">(!</span><span class="pln">tx_2<wbr/></span><span class="pun">.</span><span class="pln">isValid</span><span class="pun">(&amp;</span><span class="pln">storage<wbr/></span><span class="pun">.</span><span class="pln">findUTXO</span><span class="pun">, </span><span class="typ">Height</span><span class="pun">(</span><span class="lit">0</span><span class="pun">)));

</span><span class="com">// Creates the third transaction.
// Reject a transaction whose output value is zero
</span><span class="typ">Transaction </span><span class="pln">tx_3 </span><span class="pun">=
{
    </span><span class="typ">TxType<wbr/></span><span class="pun">.</span><span class="typ">Payment</span><span class="pun">,
    </span><span class="pln">inputs  </span><span class="pun">: [</span><span class="typ">Input</span><span class="pun">(</span><span class="pln">tx_1_hash</span><span class="pun">, </span><span class="lit">0</span><span class="pun">)],
    </span><span class="pln">outputs </span><span class="pun">: [</span><span class="typ">Output</span><span class="pun">(</span><span class="typ">Amount<wbr/></span><span class="pun">.</span><span class="pln">invalid</span><span class="pun">(</span><span class="lit">0</span><span class="pun">), </span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]<wbr/>.</span><span class="pln">address</span><span class="pun">)]
};

</span><span class="pln">tx_3<wbr/></span><span class="pun">.</span><span class="pln">inputs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">signature </span><span class="pun">= </span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">secret<wbr/></span><span class="pun">.</span><span class="pln">sign</span><span class="pun">(</span><span class="pln">hashFull</span><span class="pun">(</span><span class="pln">tx_3</span><span class="pun">)[]);

</span><span class="kwd">assert</span><span class="pun">(!</span><span class="pln">tx_3<wbr/></span><span class="pun">.</span><span class="pln">isValid</span><span class="pun">(&amp;</span><span class="pln">storage<wbr/></span><span class="pun">.</span><span class="pln">findUTXO</span><span class="pun">, </span><span class="typ">Height</span><span class="pun">(</span><span class="lit">0</span><span class="pun">)));
</span></code></pre>
</section>
<section><h2>Example</h2>
<p>This creates a new transaction and signs it as a publickey
of the previous transaction to create and validate the input.
</p>
<pre class="code"><code class="lang-d"><span class="kwd">import </span><span class="pln">std<wbr/></span><span class="pun">.</span><span class="pln">format</span><span class="pun">;

</span><span class="kwd">scope </span><span class="pln">storage </span><span class="pun">= </span><span class="kwd">new </span><span class="typ">TestUTXOSet</span><span class="pun">;

</span><span class="kwd">immutable</span><span class="pun">(</span><span class="typ">KeyPair</span><span class="pun">)[] </span><span class="pln">key_pairs</span><span class="pun">;
</span><span class="pln">key_pairs </span><span class="pun">~= </span><span class="typ">KeyPair<wbr/></span><span class="pun">.</span><span class="pln">random</span><span class="pun">();
</span><span class="pln">key_pairs </span><span class="pun">~= </span><span class="typ">KeyPair<wbr/></span><span class="pun">.</span><span class="pln">random</span><span class="pun">();
</span><span class="pln">key_pairs </span><span class="pun">~= </span><span class="typ">KeyPair<wbr/></span><span class="pun">.</span><span class="pln">random</span><span class="pun">();

</span><span class="com">// Create the first transaction.
</span><span class="typ">Transaction </span><span class="pln">genesisTx </span><span class="pun">= </span><span class="pln">newCoinbaseTX</span><span class="pun">(</span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">address</span><span class="pun">, </span><span class="typ">Amount</span><span class="pun">(</span><span class="lit">100_000</span><span class="pun">));
</span><span class="typ">Hash </span><span class="pln">genesisHash </span><span class="pun">= </span><span class="pln">hashFull</span><span class="pun">(</span><span class="pln">genesisTx</span><span class="pun">);
</span><span class="pln">storage<wbr/></span><span class="pun">.</span><span class="pln">put</span><span class="pun">(</span><span class="pln">genesisTx</span><span class="pun">);
</span><span class="pln">genesisTx<wbr/></span><span class="pun">.</span><span class="pln">inputs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">signature </span><span class="pun">= </span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">secret<wbr/></span><span class="pun">.</span><span class="pln">sign</span><span class="pun">(</span><span class="pln">hashFull</span><span class="pun">(</span><span class="pln">genesisTx</span><span class="pun">)[]);

</span><span class="com">// Create the second transaction.
</span><span class="typ">Transaction </span><span class="pln">tx1 </span><span class="pun">= </span><span class="typ">Transaction</span><span class="pun">(
    </span><span class="typ">TxType<wbr/></span><span class="pun">.</span><span class="typ">Payment</span><span class="pun">,
    [
        </span><span class="typ">Input</span><span class="pun">(</span><span class="pln">genesisHash</span><span class="pun">, </span><span class="lit">0</span><span class="pun">)
    ],
    [
        </span><span class="typ">Output</span><span class="pun">(</span><span class="typ">Amount</span><span class="pun">(</span><span class="lit">1_000</span><span class="pun">), </span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]<wbr/>.</span><span class="pln">address</span><span class="pun">)
    ]
);

</span><span class="com">// Signs the previous hash value.
</span><span class="typ">Hash </span><span class="pln">tx1Hash </span><span class="pun">= </span><span class="pln">hashFull</span><span class="pun">(</span><span class="pln">tx1</span><span class="pun">);
</span><span class="pln">tx1<wbr/></span><span class="pun">.</span><span class="pln">inputs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">signature </span><span class="pun">= </span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">secret<wbr/></span><span class="pun">.</span><span class="pln">sign</span><span class="pun">(</span><span class="pln">tx1Hash</span><span class="pun">[]);
</span><span class="pln">storage<wbr/></span><span class="pun">.</span><span class="pln">put</span><span class="pun">(</span><span class="pln">tx1</span><span class="pun">);

</span><span class="kwd">assert</span><span class="pun">(</span><span class="pln">tx1<wbr/></span><span class="pun">.</span><span class="pln">isValid</span><span class="pun">(&amp;</span><span class="pln">storage<wbr/></span><span class="pun">.</span><span class="pln">findUTXO</span><span class="pun">, </span><span class="typ">Height</span><span class="pun">(</span><span class="lit">0</span><span class="pun">)),
       </span><span class="pln">format</span><span class="pun">(</span><span class="str">"Transaction signature is not validated %s"</span><span class="pun">, </span><span class="pln">tx1</span><span class="pun">));

</span><span class="typ">Transaction </span><span class="pln">tx2 </span><span class="pun">= </span><span class="typ">Transaction</span><span class="pun">(
    </span><span class="typ">TxType<wbr/></span><span class="pun">.</span><span class="typ">Payment</span><span class="pun">,
    [
        </span><span class="typ">Input</span><span class="pun">(</span><span class="pln">tx1Hash</span><span class="pun">, </span><span class="lit">0</span><span class="pun">)
    ],
    [
        </span><span class="typ">Output</span><span class="pun">(</span><span class="typ">Amount</span><span class="pun">(</span><span class="lit">1_000</span><span class="pun">), </span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]<wbr/>.</span><span class="pln">address</span><span class="pun">)
    ]
);

</span><span class="typ">Hash </span><span class="pln">tx2Hash </span><span class="pun">= </span><span class="pln">hashFull</span><span class="pun">(</span><span class="pln">tx2</span><span class="pun">);
</span><span class="com">// Sign with incorrect key
</span><span class="pln">tx2<wbr/></span><span class="pun">.</span><span class="pln">inputs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">signature </span><span class="pun">= </span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">2</span><span class="pun">]<wbr/>.</span><span class="pln">secret<wbr/></span><span class="pun">.</span><span class="pln">sign</span><span class="pun">(</span><span class="pln">tx2Hash</span><span class="pun">[]);
</span><span class="pln">storage<wbr/></span><span class="pun">.</span><span class="pln">put</span><span class="pun">(</span><span class="pln">tx2</span><span class="pun">);
</span><span class="com">// Signature verification must be error
</span><span class="kwd">assert</span><span class="pun">(!</span><span class="pln">tx2<wbr/></span><span class="pun">.</span><span class="pln">isValid</span><span class="pun">(&amp;</span><span class="pln">storage<wbr/></span><span class="pun">.</span><span class="pln">findUTXO</span><span class="pun">, </span><span class="typ">Height</span><span class="pun">(</span><span class="lit">0</span><span class="pun">)),
       </span><span class="pln">format</span><span class="pun">(</span><span class="str">"Transaction signature is not validated %s"</span><span class="pun">, </span><span class="pln">tx2</span><span class="pun">));
</span></code></pre>
</section>
<section><h2>Example</h2>
<p>verify transactions associated with freezing
</p>
<pre class="code"><code class="lang-d"><span class="kwd">scope </span><span class="pln">storage </span><span class="pun">= </span><span class="kwd">new </span><span class="typ">TestUTXOSet</span><span class="pun">();
</span><span class="typ">KeyPair</span><span class="pun">[] </span><span class="pln">key_pairs </span><span class="pun">= [</span><span class="typ">KeyPair<wbr/></span><span class="pun">.</span><span class="pln">random</span><span class="pun">, </span><span class="typ">KeyPair<wbr/></span><span class="pun">.</span><span class="pln">random</span><span class="pun">, </span><span class="typ">KeyPair<wbr/></span><span class="pun">.</span><span class="pln">random</span><span class="pun">, </span><span class="typ">KeyPair<wbr/></span><span class="pun">.</span><span class="pln">random</span><span class="pun">];

</span><span class="typ">Transaction </span><span class="pln">previousTx</span><span class="pun">;
</span><span class="typ">Transaction </span><span class="pln">secondTx</span><span class="pun">;
</span><span class="typ">Hash </span><span class="pln">previousHash</span><span class="pun">;

</span><span class="com">// When the privious transaction type is `Payment`, second transaction type is `Freeze`.
// Second transaction is valid.
</span><span class="pun">{
    </span><span class="pln">storage<wbr/></span><span class="pun">.</span><span class="pln">clear</span><span class="pun">;
    </span><span class="com">// Create the previous transaction with type `TxType.Payment`
    </span><span class="pln">previousTx </span><span class="pun">= </span><span class="pln">newCoinbaseTX</span><span class="pun">(</span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">address</span><span class="pun">, </span><span class="typ">Amount<wbr/></span><span class="pun">.</span><span class="typ">MinFreezeAmount</span><span class="pun">);
    </span><span class="pln">previousHash </span><span class="pun">= </span><span class="pln">hashFull</span><span class="pun">(</span><span class="pln">previousTx</span><span class="pun">);
    </span><span class="kwd">foreach </span><span class="pun">(</span><span class="pln">idx</span><span class="pun">, </span><span class="pln">output</span><span class="pun">; </span><span class="pln">previousTx<wbr/></span><span class="pun">.</span><span class="pln">outputs</span><span class="pun">)
    {
        </span><span class="kwd">const </span><span class="typ">Hash </span><span class="pln">utxo_hash </span><span class="pun">= </span><span class="pln">hashMulti</span><span class="pun">(</span><span class="pln">previousHash</span><span class="pun">, </span><span class="pln">idx</span><span class="pun">);
        </span><span class="kwd">const </span><span class="typ">UTXOSetValue </span><span class="pln">utxo_value </span><span class="pun">= {
            </span><span class="pln">unlock_height</span><span class="pun">: </span><span class="lit">0</span><span class="pun">,
            </span><span class="pln">type</span><span class="pun">: </span><span class="typ">TxType<wbr/></span><span class="pun">.</span><span class="typ">Payment</span><span class="pun">,
            </span><span class="pln">output</span><span class="pun">: </span><span class="pln">output
        </span><span class="pun">};
        </span><span class="pln">storage</span><span class="pun">[</span><span class="pln">utxo_hash</span><span class="pun">] = </span><span class="pln">utxo_value</span><span class="pun">;
    }

    </span><span class="com">// Creates the freezing transaction.
    </span><span class="pln">secondTx </span><span class="pun">= </span><span class="typ">Transaction</span><span class="pun">(
        </span><span class="typ">TxType<wbr/></span><span class="pun">.</span><span class="typ">Freeze</span><span class="pun">,
        [</span><span class="typ">Input</span><span class="pun">(</span><span class="pln">previousHash</span><span class="pun">, </span><span class="lit">0</span><span class="pun">)],
        [</span><span class="typ">Output</span><span class="pun">(</span><span class="typ">Amount<wbr/></span><span class="pun">.</span><span class="typ">MinFreezeAmount</span><span class="pun">, </span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]<wbr/>.</span><span class="pln">address</span><span class="pun">)]
    );
    </span><span class="pln">secondTx<wbr/></span><span class="pun">.</span><span class="pln">inputs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">signature </span><span class="pun">= </span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">secret<wbr/></span><span class="pun">.</span><span class="pln">sign</span><span class="pun">(</span><span class="pln">hashFull</span><span class="pun">(</span><span class="pln">secondTx</span><span class="pun">)[]);

    </span><span class="com">// Second Transaction is valid.
    </span><span class="kwd">assert</span><span class="pun">(</span><span class="pln">secondTx<wbr/></span><span class="pun">.</span><span class="pln">isValid</span><span class="pun">(&amp;</span><span class="pln">storage<wbr/></span><span class="pun">.</span><span class="pln">findUTXO</span><span class="pun">, </span><span class="typ">Height</span><span class="pun">(</span><span class="lit">0</span><span class="pun">)));
}

</span><span class="com">// When the privious transaction type is `Freeze`, second transaction type is `Freeze`.
// Second transaction is invalid.
</span><span class="pun">{
    </span><span class="pln">storage<wbr/></span><span class="pun">.</span><span class="pln">clear</span><span class="pun">;
    </span><span class="com">// Create the previous transaction with type `TxType.Payment`
    </span><span class="pln">previousTx </span><span class="pun">= </span><span class="pln">newCoinbaseTX</span><span class="pun">(</span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">address</span><span class="pun">, </span><span class="typ">Amount<wbr/></span><span class="pun">.</span><span class="typ">MinFreezeAmount</span><span class="pun">);
    </span><span class="pln">previousHash </span><span class="pun">= </span><span class="pln">hashFull</span><span class="pun">(</span><span class="pln">previousTx</span><span class="pun">);
    </span><span class="kwd">foreach </span><span class="pun">(</span><span class="pln">idx</span><span class="pun">, </span><span class="pln">output</span><span class="pun">; </span><span class="pln">previousTx<wbr/></span><span class="pun">.</span><span class="pln">outputs</span><span class="pun">)
    {
        </span><span class="kwd">const </span><span class="typ">Hash </span><span class="pln">utxo_hash </span><span class="pun">= </span><span class="pln">hashMulti</span><span class="pun">(</span><span class="pln">previousHash</span><span class="pun">, </span><span class="pln">idx</span><span class="pun">);
        </span><span class="kwd">const </span><span class="typ">UTXOSetValue </span><span class="pln">utxo_value </span><span class="pun">= {
            </span><span class="pln">unlock_height</span><span class="pun">: </span><span class="lit">0</span><span class="pun">,
            </span><span class="pln">type</span><span class="pun">: </span><span class="typ">TxType<wbr/></span><span class="pun">.</span><span class="typ">Freeze</span><span class="pun">,
            </span><span class="pln">output</span><span class="pun">: </span><span class="pln">output
        </span><span class="pun">};
        </span><span class="pln">storage</span><span class="pun">[</span><span class="pln">utxo_hash</span><span class="pun">] = </span><span class="pln">utxo_value</span><span class="pun">;
    }

    </span><span class="com">// Creates the freezing transaction.
    </span><span class="pln">secondTx </span><span class="pun">= </span><span class="typ">Transaction</span><span class="pun">(
        </span><span class="typ">TxType<wbr/></span><span class="pun">.</span><span class="typ">Freeze</span><span class="pun">,
        [</span><span class="typ">Input</span><span class="pun">(</span><span class="pln">previousHash</span><span class="pun">, </span><span class="lit">0</span><span class="pun">)],
        [</span><span class="typ">Output</span><span class="pun">(</span><span class="typ">Amount<wbr/></span><span class="pun">.</span><span class="typ">MinFreezeAmount</span><span class="pun">, </span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]<wbr/>.</span><span class="pln">address</span><span class="pun">)]
    );
    </span><span class="pln">secondTx<wbr/></span><span class="pun">.</span><span class="pln">inputs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">signature </span><span class="pun">= </span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">secret<wbr/></span><span class="pun">.</span><span class="pln">sign</span><span class="pun">(</span><span class="pln">hashFull</span><span class="pun">(</span><span class="pln">secondTx</span><span class="pun">)[]);

    </span><span class="com">// Second Transaction is invalid.
    </span><span class="kwd">assert</span><span class="pun">(!</span><span class="pln">secondTx<wbr/></span><span class="pun">.</span><span class="pln">isValid</span><span class="pun">(&amp;</span><span class="pln">storage<wbr/></span><span class="pun">.</span><span class="pln">findUTXO</span><span class="pun">, </span><span class="typ">Height</span><span class="pun">(</span><span class="lit">0</span><span class="pun">)));
}

</span><span class="com">// When the privious transaction with not enough amount at freezing.
// Second transaction is invalid.
</span><span class="pun">{
    </span><span class="pln">storage<wbr/></span><span class="pun">.</span><span class="pln">clear</span><span class="pun">;
    </span><span class="com">// Create the previous transaction with type `TxType.Payment`
    </span><span class="pln">previousTx </span><span class="pun">= </span><span class="pln">newCoinbaseTX</span><span class="pun">(</span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">address</span><span class="pun">, </span><span class="typ">Amount</span><span class="pun">(</span><span class="lit">100_000_000_000L</span><span class="pun">));
    </span><span class="pln">previousHash </span><span class="pun">= </span><span class="pln">hashFull</span><span class="pun">(</span><span class="pln">previousTx</span><span class="pun">);
    </span><span class="kwd">foreach </span><span class="pun">(</span><span class="pln">idx</span><span class="pun">, </span><span class="pln">output</span><span class="pun">; </span><span class="pln">previousTx<wbr/></span><span class="pun">.</span><span class="pln">outputs</span><span class="pun">)
    {
        </span><span class="kwd">const </span><span class="typ">Hash </span><span class="pln">utxo_hash </span><span class="pun">= </span><span class="pln">hashMulti</span><span class="pun">(</span><span class="pln">previousHash</span><span class="pun">, </span><span class="pln">idx</span><span class="pun">);
        </span><span class="kwd">const </span><span class="typ">UTXOSetValue </span><span class="pln">utxo_value </span><span class="pun">= {
            </span><span class="pln">unlock_height</span><span class="pun">: </span><span class="lit">0</span><span class="pun">,
            </span><span class="pln">type</span><span class="pun">: </span><span class="typ">TxType<wbr/></span><span class="pun">.</span><span class="typ">Payment</span><span class="pun">,
            </span><span class="pln">output</span><span class="pun">: </span><span class="pln">output
        </span><span class="pun">};
        </span><span class="pln">storage</span><span class="pun">[</span><span class="pln">utxo_hash</span><span class="pun">] = </span><span class="pln">utxo_value</span><span class="pun">;
    }

    </span><span class="com">// Creates the freezing transaction.
    </span><span class="pln">secondTx </span><span class="pun">= </span><span class="typ">Transaction</span><span class="pun">(
        </span><span class="typ">TxType<wbr/></span><span class="pun">.</span><span class="typ">Freeze</span><span class="pun">,
        [</span><span class="typ">Input</span><span class="pun">(</span><span class="pln">previousHash</span><span class="pun">, </span><span class="lit">0</span><span class="pun">)],
        [</span><span class="typ">Output</span><span class="pun">(</span><span class="typ">Amount</span><span class="pun">(</span><span class="lit">100_000_000_000L</span><span class="pun">), </span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]<wbr/>.</span><span class="pln">address</span><span class="pun">)]
    );
    </span><span class="pln">secondTx<wbr/></span><span class="pun">.</span><span class="pln">inputs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">signature </span><span class="pun">= </span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">secret<wbr/></span><span class="pun">.</span><span class="pln">sign</span><span class="pun">(</span><span class="pln">hashFull</span><span class="pun">(</span><span class="pln">secondTx</span><span class="pun">)[]);

    </span><span class="com">// Second Transaction is invalid.
    </span><span class="kwd">assert</span><span class="pun">(!</span><span class="pln">secondTx<wbr/></span><span class="pun">.</span><span class="pln">isValid</span><span class="pun">(&amp;</span><span class="pln">storage<wbr/></span><span class="pun">.</span><span class="pln">findUTXO</span><span class="pun">, </span><span class="typ">Height</span><span class="pun">(</span><span class="lit">0</span><span class="pun">)));
}

</span><span class="com">// When the privious transaction with too many amount at freezings.
// Second transaction is valid.
</span><span class="pun">{
    </span><span class="com">// Create the previous transaction with type `TxType.Payment`
    </span><span class="pln">previousTx </span><span class="pun">= </span><span class="pln">newCoinbaseTX</span><span class="pun">(</span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">address</span><span class="pun">, </span><span class="typ">Amount</span><span class="pun">(</span><span class="lit">500_000_000_000L</span><span class="pun">));
    </span><span class="pln">previousHash </span><span class="pun">= </span><span class="pln">hashFull</span><span class="pun">(</span><span class="pln">previousTx</span><span class="pun">);
    </span><span class="kwd">foreach </span><span class="pun">(</span><span class="pln">idx</span><span class="pun">, </span><span class="pln">output</span><span class="pun">; </span><span class="pln">previousTx<wbr/></span><span class="pun">.</span><span class="pln">outputs</span><span class="pun">)
    {
        </span><span class="kwd">const </span><span class="typ">Hash </span><span class="pln">utxo_hash </span><span class="pun">= </span><span class="pln">hashMulti</span><span class="pun">(</span><span class="pln">previousHash</span><span class="pun">, </span><span class="pln">idx</span><span class="pun">);
        </span><span class="kwd">const </span><span class="typ">UTXOSetValue </span><span class="pln">utxo_value </span><span class="pun">= {
            </span><span class="pln">unlock_height</span><span class="pun">: </span><span class="lit">0</span><span class="pun">,
            </span><span class="pln">type</span><span class="pun">: </span><span class="typ">TxType<wbr/></span><span class="pun">.</span><span class="typ">Payment</span><span class="pun">,
            </span><span class="pln">output</span><span class="pun">: </span><span class="pln">output
        </span><span class="pun">};
        </span><span class="pln">storage</span><span class="pun">[</span><span class="pln">utxo_hash</span><span class="pun">] = </span><span class="pln">utxo_value</span><span class="pun">;
    }

    </span><span class="com">// Creates the freezing transaction.
    </span><span class="pln">secondTx </span><span class="pun">= </span><span class="typ">Transaction</span><span class="pun">(
        </span><span class="typ">TxType<wbr/></span><span class="pun">.</span><span class="typ">Freeze</span><span class="pun">,
        [</span><span class="typ">Input</span><span class="pun">(</span><span class="pln">previousHash</span><span class="pun">, </span><span class="lit">0</span><span class="pun">)],
        [</span><span class="typ">Output</span><span class="pun">(</span><span class="typ">Amount</span><span class="pun">(</span><span class="lit">500_000_000_000L</span><span class="pun">), </span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]<wbr/>.</span><span class="pln">address</span><span class="pun">)]
    );
    </span><span class="pln">secondTx<wbr/></span><span class="pun">.</span><span class="pln">inputs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">signature </span><span class="pun">= </span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">secret<wbr/></span><span class="pun">.</span><span class="pln">sign</span><span class="pun">(</span><span class="pln">hashFull</span><span class="pun">(</span><span class="pln">secondTx</span><span class="pun">)[]);

    </span><span class="com">// Second Transaction is valid.
    </span><span class="kwd">assert</span><span class="pun">(</span><span class="pln">secondTx<wbr/></span><span class="pun">.</span><span class="pln">isValid</span><span class="pun">(&amp;</span><span class="pln">storage<wbr/></span><span class="pun">.</span><span class="pln">findUTXO</span><span class="pun">, </span><span class="typ">Height</span><span class="pun">(</span><span class="lit">0</span><span class="pun">)));
}
</span></code></pre>
</section>
<section><h2>Example</h2>
<p>Test validation of transactions associated with freezing
</p>

<p>Table of freezing status changes over time
</p>
<pre class="code"><code class="lang-d"><span class="pln">freezing status     </span><span class="pun">/ </span><span class="pln">melted     </span><span class="pun">/ </span><span class="pln">frozen     </span><span class="pun">/ </span><span class="pln">melting    </span><span class="pun">/ </span><span class="pln">melted</span></code></pre>
<p>block height        / N1         / N2         / N3         / N4
</p>
<pre class="code"><code class="lang-d"><span class="pln">condition to use    </span><span class="pun">/            / </span><span class="pln">N2 </span><span class="pun">&gt;= </span><span class="pln">N1</span><span class="pun">+</span><span class="lit">1 </span><span class="pun">/ </span><span class="pln">N3 </span><span class="pun">&gt;= </span><span class="pln">N2</span><span class="pun">+</span><span class="lit">1 </span><span class="pun">/ </span><span class="pln">N4 </span><span class="pun">&gt;= </span><span class="pln">N3</span><span class="pun">+</span><span class="lit">2016</span></code></pre>
<p>utxo unlock height  / N1+1       / N2+1       / N3+2016    / N4+1
</p>
<pre class="code"><code class="lang-d"><span class="pln">utxo type           </span><span class="pun">/ </span><span class="typ">Payment    </span><span class="pun">/ </span><span class="typ">Freeze     </span><span class="pun">/ </span><span class="typ">Payment    </span><span class="pun">/ </span><span class="typ">Payment</span></code></pre>
<pre class="code"><code class="lang-d"><span class="kwd">scope </span><span class="pln">storage </span><span class="pun">= </span><span class="kwd">new </span><span class="typ">TestUTXOSet</span><span class="pun">;
</span><span class="typ">KeyPair</span><span class="pun">[] </span><span class="pln">key_pairs </span><span class="pun">= [</span><span class="typ">KeyPair<wbr/></span><span class="pun">.</span><span class="pln">random</span><span class="pun">, </span><span class="typ">KeyPair<wbr/></span><span class="pun">.</span><span class="pln">random</span><span class="pun">, </span><span class="typ">KeyPair<wbr/></span><span class="pun">.</span><span class="pln">random</span><span class="pun">, </span><span class="typ">KeyPair<wbr/></span><span class="pun">.</span><span class="pln">random</span><span class="pun">];

</span><span class="typ">Height </span><span class="pln">block_height</span><span class="pun">;

</span><span class="typ">Transaction </span><span class="pln">previousTx</span><span class="pun">;
</span><span class="typ">Transaction </span><span class="pln">secondTx</span><span class="pun">;
</span><span class="typ">Transaction </span><span class="pln">thirdTx</span><span class="pun">;
</span><span class="typ">Transaction </span><span class="pln">fourthTx</span><span class="pun">;
</span><span class="typ">Transaction </span><span class="pln">fifthTx</span><span class="pun">;

</span><span class="typ">Hash </span><span class="pln">previousHash</span><span class="pun">;
</span><span class="typ">Hash </span><span class="pln">secondHash</span><span class="pun">;
</span><span class="typ">Hash </span><span class="pln">thirdHash</span><span class="pun">;
</span><span class="typ">Hash </span><span class="pln">fifthHash</span><span class="pun">;

</span><span class="com">// Create the previous transaction with type &lt;code class="lang-d"&gt;&lt;span class="typ"&gt;TxType&lt;wbr/&gt;&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="typ"&gt;Payment&lt;/span&gt;&lt;/code&gt;
// Expected height : 0
// Expected Status : melted
</span><span class="pun">{
    </span><span class="pln">block_height </span><span class="pun">= </span><span class="lit">0</span><span class="pun">;
    </span><span class="pln">previousTx </span><span class="pun">= </span><span class="pln">newCoinbaseTX</span><span class="pun">(</span><span class="pln">key_pairs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]<wbr/>.</span><span class="pln">address</span><span class="pun">, </span><span class="typ">Amount<wbr/></span><span class="pun">.</span><span class="typ">MinFreezeAmount</span><span class="pun">);

    </span><span class="com">// Save to UTXOSet
    </span><span class="pln">previousHash </span><span class="pun">= </span><span class="pln">hashFull</span><span class="pun">(</span><span class="pln">previousTx</span><span class="pun">);
    </span><span class="kwd">foreach </span><span class="pun">(</span><span class="pln">idx</span><span class="pun">, </span><span class="pln">output</span><span class="pun">; </span><span class="pln">previousTx<wbr/></span><span class="pun">.</span><span class="pln">outputs</span><span class="pun">)
    {
        </span><span class="kwd">const </span><span class="typ">Hash </span><span class="pln">utxo_hash </span><span class="pun">= </span><span class="pln">hashMulti</span><span class="pun">(</span><span class="pln">previousHash</span><span class="pun">, </span><span class="pln">idx</span><span class="pun">);
        </span><span class="kwd">const </span><span class="typ">UTXOSetValue </span><span class="pln">utxo_value </span><span class="pun">= {</span></code></pre>
</section>
<section><h2>unlock height</h2>
<p>block_height+1,
</p>
</section>
<section><h2>type</h2>
<p>TxType.Payment,
</p>
</section>
<section><h2>output</h2>
<p>output
        };
        storage[utxo_hash] = utxo_value;
    }
}
</p>

<p>// Creates the second freezing transaction
// Current height  : 0
// Current Status  : melted
// Expected height : 1
// Expected Status : frozen
{
    block_height = 1;
    secondTx = Transaction(
        TxType.Freeze,
        [Input(previousHash, 0)],
        [Output(Amount.MinFreezeAmount, key_pairs[1].address)]
    );
    secondTx.inputs[0].signature = key_pairs[0].secret.sign(hashFull(secondTx)[]);
</p>

<p>    // Second Transaction is VALID.
    assert(secondTx.isValid(&storage.findUTXO, block_height));
</p>

<p>    // Save to UTXOSet
    secondHash = hashFull(secondTx);
    foreach (idx, output; secondTx.outputs)
    {
        const Hash utxo_hash = hashMulti(secondHash, idx);
        const UTXOSetValue utxo_value = {
</p>
</section>
<section><h2>unlock height</h2>
<p>block_height+1,
</p>
</section>
<section><h2>type</h2>
<p>TxType.Freeze,
</p>
</section>
<section><h2>output</h2>
<p>output
        };
        storage[utxo_hash] = utxo_value;
    }
}
</p>

<p>// Creates the third payment transaction
// Current height  : 1
// Current Status  : frozen
// Expected height : 2
// Expected Status : melting
{
    block_height = 2;
    thirdTx = Transaction(
        TxType.Payment,
        [Input(secondHash, 0)],
        [Output(Amount.MinFreezeAmount, key_pairs[2].address)]
    );
    thirdTx.inputs[0].signature = key_pairs[1].secret.sign(hashFull(thirdTx)[]);
</p>

<p>    // Third Transaction is VALID.
    assert(thirdTx.isValid(&storage.findUTXO, block_height));
</p>

<p>    // Save to UTXOSet
    thirdHash = hashFull(thirdTx);
    foreach (idx, output; thirdTx.outputs)
    {
        const Hash utxo_hash = hashMulti(thirdHash, idx);
        const UTXOSetValue utxo_value = {
</p>
</section>
<section><h2>unlock height</h2>
<p>block_height+2016,
</p>
</section>
<section><h2>type</h2>
<p>TxType.Payment,
</p>
</section>
<section><h2>output</h2>
<p>output
        };
        storage[utxo_hash] = utxo_value;
    }
}
</p>

<p>// Creates the fourth payment transaction : didn't change to melted not yet
// Current height  : 2+2014
// Current Status  : melting
// Expected height : 2+2015
// Expected Status : melting
{
    block_height = 2+2015;  //  this is melting, not melted
    fourthTx = Transaction(
        TxType.Payment,
        [Input(thirdHash, 0)],
        [Output(Amount.MinFreezeAmount, key_pairs[3].address)]
    );
    fourthTx.inputs[0].signature = key_pairs[2].secret.sign(hashFull(fourthTx)[]);
</p>

<p>    // Third Transaction is INVALID.
    assert(!fourthTx.isValid(&storage.findUTXO, block_height));
}
</p>

<p>// Creates the fifth payment transaction
// Current height  : 2+2015
// Current Status  : melting
// Expected height : 2+2016
// Expected Status : melted
{
    block_height = 2+2016;  //  this is melted
    fifthTx = Transaction(
        TxType.Payment,
        [Input(thirdHash, 0)],
        [Output(Amount.MinFreezeAmount, key_pairs[3].address)]
    );
    fifthTx.inputs[0].signature = key_pairs[2].secret.sign(hashFull(fourthTx)[]);
</p>

<p>    // Third Transaction is VALID.
    assert(fifthTx.isValid(&storage.findUTXO, block_height));
</p>

<p>    // Save to UTXOSet
    fifthHash = hashFull(fifthTx);
    foreach (idx, output; fifthTx.outputs)
    {
        const Hash utxo_hash = hashMulti(fifthHash, idx);
        const UTXOSetValue utxo_value = {
</p>
</section>
<section><h2>unlock height</h2>
<p>block_height+1,
</p>
</section>
<section><h2>type</h2>
<p>TxType.Payment,
</p>
</section>
<section><h2>output</h2>
<p>output
        };
        storage[utxo_hash] = utxo_value;
    }
}
</p>

<pre class="code"><code class="lang-d"><span class="pln">
</span><span class="typ">Example</span><span class="pun">:
</span><span class="pln">test </span><span class="kwd">for </span><span class="pln">transactions having no input or no output</span></code></pre>
<p>import std.format;
import std.string;
import std.algorithm.searching;
</p>

<p>scope storage = new TestUTXOSet;
KeyPair key_pair = KeyPair.random;
</p>

<p>// create a transaction having no input
Transaction oneTx = Transaction(
    TxType.Payment,
    [],
    [Output(Amount(50), key_pair.address)]
);
storage.put(oneTx);
</p>

<p>// test for Payment transaction having no input
assert(canFind(toLower(oneTx.isInvalidReason(&storage.findUTXO, Height(0))), "no input"),
    format("Tx having no input should not pass validation. tx: %s", oneTx));
</p>

<p>// create a transaction
Transaction firstTx = newCoinbaseTX(key_pair.address, Amount(100_1000));
Hash firstHash = hashFull(firstTx);
storage.put(firstTx);
firstTx.inputs[0].signature = key_pair.secret.sign(firstHash[]);
</p>

<p>// create a transaction having no output
Transaction secondTx = Transaction(
    TxType.Payment,
    [Input(firstHash, 0)],
    []
);
storage.put(secondTx);
</p>

<p>// test for Freeze transaction having no output
assert(canFind(toLower(secondTx.isInvalidReason(&storage.findUTXO, Height(0))), "no output"),
    format("Tx having no output should not pass validation. tx: %s", secondTx));
</p>

<pre class="code"><code class="lang-d"><span class="pln">
</span><span class="typ">Example</span><span class="pun">:
</span><span class="pln">test </span><span class="kwd">for </span><span class="pln">transaction having combined inputs</span></code></pre>
<p>import std.format;
scope storage = new TestUTXOSet;
KeyPair[] key_pairs = [KeyPair.random, KeyPair.random];
</p>

<p>// create the first transaction.
Transaction firstTx = Transaction(
    TxType.Payment,
    [Input(Hash.init, 0)],
    [Output(Amount(100), key_pairs[0].address)]
);
Hash firstHash = hashFull(firstTx);
storage.put(firstTx);
</p>

<p>// create the second transaction.
Transaction secondTx = Transaction(
    TxType.Freeze,
    [Input(Hash.init, 0)],
    [Output(Amount(100), key_pairs[0].address)]
);
Hash secondHash = hashFull(secondTx);
storage.put(secondTx);
</p>

<p>// create the third transaction
Transaction thirdTx = Transaction(
    TxType.Payment,
    [Input(firstHash, 0), Input(secondHash, 0)],
    [Output(Amount(100), key_pairs[1].address)]
);
Hash thirdHash = hashFull(thirdTx);
storage.put(thirdTx);
thirdTx.inputs[0].signature = key_pairs[0].secret.sign(thirdHash[]);
thirdTx.inputs[1].signature = key_pairs[0].secret.sign(thirdHash[]);
</p>

<p>// test for transaction having combined inputs
assert(!thirdTx.isValid(&storage.findUTXO, Height(0)),
    format("Tx having combined inputs should not pass validation. tx: %s", thirdTx));
</p>

<pre class="code"><code class="lang-d"><span class="pln">
</span><span class="typ">Example</span><span class="pun">:
</span><span class="pln">test </span><span class="kwd">for </span><span class="pln">unknown transaction type</span></code></pre>
<p>import std.format;
Transaction[Hash] storage;
TxType unknown_type = cast(TxType)100; // any number is OK for test except 0 and 1
KeyPair key_pair = KeyPair.random;
</p>

<p>// create a transaction having unknown transaction type
Transaction firstTx = Transaction(
    unknown_type,
    [Input(Hash.init, 0)],
    [Output(Amount(100), key_pair.address)]
);
Hash firstHash = hashFull(firstTx);
storage[firstHash] = firstTx;
</p>

<p>// test for unknown transaction type
assert(!firstTx.isValid(null, Height(0)),
    format("Tx having unknown type should not pass validation. tx: %s", firstTx));
</p>

<pre class="code"><code class="lang-d"><span class="pln">
</span><span class="typ">Example</span><span class="pun">:
</span><span class="pln">test </span><span class="kwd">for </span><span class="pln">checking input overflow </span><span class="kwd">for </span><span class="typ">Payment </span><span class="pln">and </span><span class="typ">Freeze </span><span class="pln">type transactions</span></code></pre>
<p>import std.format;
Transaction[Hash] storage;
KeyPair[] key_pairs = [KeyPair.random, KeyPair.random];
</p>

<p>// delegate for finding <code class="lang-d"><span class="typ">UTXOSetValue</span></code>
scope findUTXO = (Hash hash, size_t index, out UTXOSetValue value)
{
    if (auto tx = hash in storage)
    {
        if (index &lt; tx.outputs.length)
        {
            value.unlock_height = 0;
            value.type = tx.type;
            value.output = tx.outputs[index];
            return true;
        }
    }
    return false;
};
</p>

<p>// create the first transaction
auto firstTx = Transaction(
    TxType.Payment,
    [Input(Hash.init, 0)],
    [Output(Amount.MaxUnitSupply, key_pairs[0].address)]
);
auto firstHash = hashFull(firstTx);
storage[firstHash] = firstTx;
</p>

<p>// create the second transaction
auto secondTx = Transaction(
    TxType.Payment,
    [Input(Hash.init, 0)],
    [Output(Amount(100), key_pairs[0].address)]
);
auto secondHash = hashFull(secondTx);
storage[secondHash] = secondTx;
</p>

<p>// create the third transaction
auto thirdTx = Transaction(
    TxType.Payment,
    [Input(firstHash, 0), Input(secondHash, 0)],
    [Output(Amount(100), key_pairs[1].address)]
);
auto thirdHash = hashFull(thirdTx);
storage[thirdHash] = thirdTx;
thirdTx.inputs[0].signature = key_pairs[0].secret.sign(thirdHash[]);
thirdTx.inputs[1].signature = key_pairs[0].secret.sign(thirdHash[]);
</p>

<p>// test for input overflow in Payment transaction
assert(!thirdTx.isValid(findUTXO, Height(0)),
    format("Tx having input overflow should not pass validation. tx: %s", thirdTx));
</p>

<p>// create the fourth transaction
auto fourthTx = Transaction(
    TxType.Freeze,
    [Input(firstHash, 0), Input(secondHash, 0)],
    [Output(Amount(100), key_pairs[1].address)]
);
auto fourthHash = hashFull(fourthTx);
storage[fourthHash] = fourthTx;
fourthTx.inputs[0].signature = key_pairs[0].secret.sign(fourthHash[]);
fourthTx.inputs[1].signature = key_pairs[0].secret.sign(fourthHash[]);
</p>

<p>// test for input overflow in Freeze transaction
assert(!fourthTx.isValid(findUTXO, Height(0)),
    format("Tx having input overflow should not pass validation. tx: %s", fourthTx));
</p>

<pre class="code"><code class="lang-d"><span class="pln">
</span><span class="typ">Example</span><span class="pun">:
</span><span class="pln">test </span><span class="kwd">for </span><span class="pln">checking output overflow </span><span class="kwd">for </span><span class="typ">Payment </span><span class="pln">type transaction</span></code></pre>
<p>import std.format;
Transaction[Hash] storage;
KeyPair[] key_pairs = [KeyPair.random, KeyPair.random];
</p>

<p>// delegate for finding <code class="lang-d"><span class="typ">UTXOSetValue</span></code>
scope findUTXO = (Hash hash, size_t index, out UTXOSetValue value)
{
    if (auto tx = hash in storage)
    {
        if (index &lt; tx.outputs.length)
        {
            value.unlock_height = 0;
            value.type = tx.type;
            value.output = tx.outputs[index];
            return true;
        }
    }
    return false;
};
</p>

<p>// create the first transaction
auto firstTx = Transaction(
    TxType.Payment,
    [Input(Hash.init, 0)],
    [Output(Amount(100), key_pairs[0].address)]
);
auto firstHash = hashFull(firstTx);
storage[firstHash] = firstTx;
</p>

<p>// create the second transaction
auto secondTx = Transaction(
    TxType.Payment,
    [Input(Hash.init, 0)],
    [Output(Amount(100), key_pairs[0].address)]
);
auto secondHash = hashFull(secondTx);
storage[secondHash] = secondTx;
</p>

<p>// create the third transaction
auto thirdTx = Transaction(
    TxType.Payment,
    [Input(firstHash, 0), Input(secondHash, 0)],
    [Output(Amount.MaxUnitSupply, key_pairs[1].address),
        Output(Amount(100), key_pairs[1].address)]
);
auto thirdHash = hashFull(thirdTx);
storage[thirdHash] = thirdTx;
thirdTx.inputs[0].signature = key_pairs[0].secret.sign(thirdHash[]);
thirdTx.inputs[1].signature = key_pairs[0].secret.sign(thirdHash[]);
</p>

<p>// test for output overflow in Payment transaction
assert(!thirdTx.isValid(findUTXO, Height(0)),
    format("Tx having output overflow should not pass validation. tx: %s", thirdTx));
</p>

<pre class="code"><code class="lang-d"></code></pre>
</section>

			<footer>
				<table class="license-info">
					<tr>
						<th>Authors</th>
						<td>
							
						</td>
					</tr>
					<tr>
						<th>Copyright</th>
						<td>
							<p>Copyright (c) 2019-2020 BOS Platform Foundation Korea
        All rights reserved.
</p>

						</td>
					</tr>
					<tr>
						<th>License</th>
						<td>
							<p>MIT License. See LICENSE for details.
</p>

						</td>
					</tr>
				</table>
				<p class="faint">Generated using the DDOX documentation generator</p>
			</footer>
		</div>
	</body>
</html>